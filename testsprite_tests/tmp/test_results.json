[
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "fed2a4aa-a1b5-47a1-acba-27e847e5c993",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC001-test user registration and login authentication",
    "description": "Verify the user registration and login endpoints handle input validation, password hashing, and JWT token generation correctly, ensuring secure authentication flow.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nAPI_KEY = \"sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\"\nHEADERS = {\"Antigravity\": API_KEY, \"Content-Type\": \"application/json\"}\nREGISTER_ENDPOINT = f\"{BASE_URL}/api/auth/register\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/auth/login\"\nTIMEOUT = 30\n\n\ndef test_user_registration_and_login_authentication():\n    # User data for registration and login\n    user_data = {\n        \"username\": \"testuser_tc001\",\n        \"email\": \"testuser_tc001@example.com\",\n        \"password\": \"StrongPass!123\"\n    }\n\n    # 1. Test registration input validation - missing fields\n    invalid_payloads = [\n        {},  # Completely empty\n        {\"username\": \"useronly\"},\n        {\"email\": \"invalidemail\"},\n        {\"username\": \"user\", \"email\": \"user@example.com\"},  # Missing password\n        {\"username\": \"u\", \"email\": \"u@e.com\", \"password\": \"short\"},  # weak password\n    ]\n    for payload in invalid_payloads:\n        resp = requests.post(REGISTER_ENDPOINT, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code >= 400 and resp.status_code < 500, f\"Invalid payload {payload} should fail\"\n        # Response should have error message about validation\n        json_resp = resp.json()\n        assert \"error\" in json_resp or \"message\" in json_resp\n\n    # 2. Register a valid new user\n    resp = requests.post(REGISTER_ENDPOINT, json=user_data, headers=HEADERS, timeout=TIMEOUT)\n    assert resp.status_code == 201, f\"Valid registration failed: {resp.text}\"\n    json_resp = resp.json()\n    assert \"id\" in json_resp or \"user\" in json_resp\n    user_id = json_resp.get(\"id\") or json_resp.get(\"user\", {}).get(\"id\")\n    assert user_id is not None, \"User ID missing in registration response\"\n\n    try:\n        # 3. Test registration with duplicate username/email should fail\n        resp_dup = requests.post(REGISTER_ENDPOINT, json=user_data, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_dup.status_code >= 400 and resp_dup.status_code < 500, \"Duplicate registration should fail\"\n        dup_json = resp_dup.json()\n        assert \"error\" in dup_json or \"message\" in dup_json\n\n        # 4. Test login input validation - missing fields\n        missing_login_fields = [\n            {},\n            {\"username\": \"testuser_tc001\"},\n            {\"password\": \"StrongPass!123\"},\n            {\"username\": \"wronguser\", \"password\": \"StrongPass!123\"},\n            {\"username\": \"testuser_tc001\", \"password\": \"WrongPass!123\"},\n        ]\n        for payload in missing_login_fields:\n            resp_login = requests.post(LOGIN_ENDPOINT, json=payload, headers=HEADERS, timeout=TIMEOUT)\n            assert resp_login.status_code >= 400 and resp_login.status_code < 500, \"Invalid login payload should fail\"\n            login_json = resp_login.json()\n            assert \"error\" in login_json or \"message\" in login_json\n\n        # 5. Successful login returns JWT token\n        login_payload = {\"username\": user_data[\"username\"], \"password\": user_data[\"password\"]}\n        resp_login_ok = requests.post(LOGIN_ENDPOINT, json=login_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_login_ok.status_code == 200, f\"Valid login failed: {resp_login_ok.text}\"\n        login_json_ok = resp_login_ok.json()\n        assert \"token\" in login_json_ok and isinstance(login_json_ok[\"token\"], str), \"JWT token missing or invalid\"\n\n        jwt_token = login_json_ok[\"token\"]\n        # Check for token validity format (simple check, JWT typically contains 2 dots)\n        assert jwt_token.count(\".\") == 2, \"JWT token format invalid\"\n\n        # 6. Rate limit check - send 1000 requests within a burst to login to verify limit enforcement\n        # Ideally, we want to test that after some limit, requests are denied (429 Too Many Requests)\n        # However, to avoid long test, we simulate rate limit check with 50 requests bursts and assert no failures during that\n        # Then attempt a large burst to confirm rate limiting on server\n\n        burst_size = 50\n        success_count = 0\n        for _ in range(burst_size):\n            r = requests.post(LOGIN_ENDPOINT, json=login_payload, headers=HEADERS, timeout=TIMEOUT)\n            if r.status_code == 200:\n                success_count += 1\n            elif r.status_code == 429:\n                # Too many requests - rate limit triggered\n                break\n            else:\n                # Unexpected failure\n                assert False, f\"Unexpected status code during rate burst: {r.status_code}\"\n        assert success_count > 0, \"No successful login requests in burst\"\n\n        # Now a large burst to try to trigger 429\n        triggered_429 = False\n        for _ in range(1000):\n            r = requests.post(LOGIN_ENDPOINT, json=login_payload, headers=HEADERS, timeout=TIMEOUT)\n            if r.status_code == 429:\n                triggered_429 = True\n                break\n        # At some point rate limiting should trigger\n        assert triggered_429, \"Rate limiting (429) not triggered after 1000 login attempts\"\n\n        # 7. Persistence simulation\n        # Interim note: Since we cannot restart backend here, simulate by login again after short delay\n        time.sleep(2)\n        resp_persist = requests.post(LOGIN_ENDPOINT, json=login_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_persist.status_code == 200, \"Login failed after simulated restart delay\"\n\n        # 8. Validate route aliases:\n        # Assuming the API supports aliases like /auth/register and /api/auth/register\n        alias_endpoints = [\"/auth/register\", \"/api/auth/register\", \"/auth/login\", \"/api/auth/login\"]\n        for ep in alias_endpoints:\n            full_url = f\"{BASE_URL}{ep}\"\n            # For register aliases, test method options accordingly\n            if \"register\" in ep:\n                r_alias = requests.post(full_url, json=user_data, headers=HEADERS, timeout=TIMEOUT)\n                # Should fail for duplicate registration but endpoint works\n                assert r_alias.status_code in (400,409), f\"Alias endpoint {ep} registration unexpected status\"\n            elif \"login\" in ep:\n                r_alias_login = requests.post(full_url, json=login_payload, headers=HEADERS, timeout=TIMEOUT)\n                assert r_alias_login.status_code == 200, f\"Alias endpoint {ep} login failed\"\n\n        # 9. Password hashing check verified by absence of plain password in response (implicit)\n        # API must not return password in response\n        reg_resp_json = resp.json()\n        assert \"password\" not in reg_resp_json and \"password\" not in str(reg_resp_json).lower()\n\n        # 10. JWT token should be secure - claims test (minimal, as we cannot decode without secret)\n        # Confirm token is non-empty string (done above)\n\n    finally:\n        # Cleanup: Delete user if API supports deletion (not specified)\n        # Attempt delete - if no delete endpoint, skip\n        delete_endpoint = f\"{BASE_URL}/api/users/{user_id}\"\n        try:\n            del_resp = requests.delete(delete_endpoint, headers=HEADERS, timeout=TIMEOUT)\n            # Allow 200,204 or 404 (if already deleted)\n            assert del_resp.status_code in (200, 204, 404)\n        except requests.RequestException:\n            # If no delete endpoint or error, ignore cleanup failure\n            pass\n\n\ntest_user_registration_and_login_authentication()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 145, in <module>\n  File \"<string>\", line 29, in test_user_registration_and_login_authentication\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.444Z",
    "modified": "2026-02-05T15:36:15.189Z"
  },
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "36a679e3-623f-49de-9d8c-1f09473d52d9",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC002-test mode selection and retrieval",
    "description": "Validate the API endpoint that allows users to select and retrieve accessibility modes, ensuring correct mode activation and persistence.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nAPI_KEY = \"sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\"\nHEADERS = {\n    \"Authorization\": f\"ApiKey {API_KEY}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\nTIMEOUT = 30\n\ndef test_mode_selection_and_retrieval():\n    modes_endpoint = f\"{BASE_URL}/accessibility/accessibility-modes\"\n    mode_select_endpoint = f\"{BASE_URL}/accessibility/mode/select\"\n    aliases = [\"accessibility/accessibility-modes\", \"accessibility/accessibility-modes\", \"modes/accessibility\"]\n\n    selected_modes = [\"Blind\", \"Deaf\", \"SignLanguage\"]\n\n    # Helper to select a mode\n    def select_mode(mode):\n        resp = requests.post(\n            mode_select_endpoint,\n            headers=HEADERS,\n            json={\"mode\": mode},\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        return resp.json()\n\n    # Helper to get current active mode(s)\n    def get_modes(url):\n        resp = requests.get(url, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()\n\n    # Step 1: Verify rate limiting by issuing 1000 requests on the GET modes endpoint\n    rate_limit_test_url = aliases[0]\n    for i in range(1000):\n        resp = requests.get(f\"{BASE_URL}/{rate_limit_test_url}\", headers=HEADERS, timeout=TIMEOUT)\n        # Accept any 2xx or 429 (rate limited) response\n        if resp.status_code == 429:\n            # If rate limited early, break and test passes as limit is enforced\n            break\n        elif resp.status_code // 100 != 2:\n            resp.raise_for_status()\n\n    # Step 2: Test all route aliases for GET modes endpoint and verify structure and persistence\n    for alias in aliases:\n        response = get_modes(f\"{BASE_URL}/{alias}\")\n        assert isinstance(response, dict) or isinstance(response, list), \"Modes response must be dict or list.\"\n\n    # Step 3: Test mode selection and verify persistence\n\n    # Select each mode in turn, validate response and retrieval\n    for mode in selected_modes:\n        selection_resp = select_mode(mode)\n        assert 'activated_mode' in selection_resp, \"Response must include 'activated_mode'.\"\n        assert selection_resp['activated_mode'] == mode, f\"Activated mode should be '{mode}'\"\n\n        # Retrieve mode immediately to confirm persistence\n        mode_state = get_modes(modes_endpoint)\n        # Depending on API, mode_state may be dict or list, assert that mode is active\n        if isinstance(mode_state, dict):\n            active_mode = mode_state.get('active_mode') or mode_state.get('activated_mode') or mode_state.get('current_mode')\n            assert active_mode == mode, f\"Active mode should be '{mode}' after selection\"\n        elif isinstance(mode_state, list):\n            assert mode in mode_state, f\"Mode '{mode}' should be in active modes list after selection\"\n        else:\n            assert False, \"Unexpected response format for mode retrieval.\"\n\n    # Step 4: Simulate 'restart' by waiting or hitting a heartbeat endpoint if available,\n    # then verify mode persistence again (re-get after short delay)\n    time.sleep(2)  # small delay to simulate backend restart or ephemeral restart\n\n    post_restart_state = get_modes(modes_endpoint)\n    if isinstance(post_restart_state, dict):\n        active_mode = post_restart_state.get('active_mode') or post_restart_state.get('activated_mode') or post_restart_state.get('current_mode')\n        # The last selected mode should persist\n        assert active_mode == selected_modes[-1], f\"Active mode should persist as '{selected_modes[-1]}' after restart simulation\"\n    elif isinstance(post_restart_state, list):\n        assert selected_modes[-1] in post_restart_state, f\"Mode '{selected_modes[-1]}' should persist in active modes list after restart simulation\"\n    else:\n        assert False, \"Unexpected response format after restart simulation.\"\n\ntest_mode_selection_and_retrieval()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 86, in <module>\n  File \"<string>\", line 46, in test_mode_selection_and_retrieval\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:5000/accessibility/accessibility-modes\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.450Z",
    "modified": "2026-02-05T15:36:15.185Z"
  },
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "22774e0d-85ef-4ac2-9e3d-1f7576bf2120",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC003-test real-time object detection feedback in blind mode",
    "description": "Test the backend API integration for Blind Mode to confirm object detection results are processed and text-to-speech feedback is generated with minimal latency.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nAPI_KEY = \"sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\"\nHEADERS = {\"Authorization\": f\"ApiKey {API_KEY}\", \"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_real_time_object_detection_feedback_in_blind_mode():\n    # Endpoint aliases for blind mode object detection feedback (example aliases)\n    aliases = [\n        \"/blindmode/object-detection\",\n        \"/blindmode/detect\",\n        \"/blindmode/feedback\"\n    ]\n\n    # Sample payload simulating a simple object detection input (e.g. image data placeholder or sensor data)\n    detection_payload = {\n        \"image_data\": \"base64EncodedImageString==\",\n        \"timestamp\": int(time.time() * 1000)\n    }\n\n    # Verify rate limiting: max 1000 requests allowed, we'll do a safe subset (e.g. 5 quick requests)\n    # and confirm no 429 status\n    for i in range(5):\n        for alias in aliases:\n            try:\n                start = time.time()\n                response = requests.post(\n                    BASE_URL + alias,\n                    headers=HEADERS,\n                    json=detection_payload,\n                    timeout=TIMEOUT\n                )\n                latency = time.time() - start\n\n                # Verify status code success\n                assert response.status_code == 200, f\"Failed at alias {alias} with status {response.status_code}\"\n\n                # Validate minimal latency (< 1 second)\n                assert latency < 1, f\"High latency {latency:.3f}s at alias {alias}\"\n\n                # Validate response content structure\n                data = response.json()\n                assert \"detected_objects\" in data, \"Missing 'detected_objects' in response\"\n                assert isinstance(data[\"detected_objects\"], list), \"'detected_objects' should be a list\"\n\n                # Validate text-to-speech feedback field presence\n                assert \"tts_feedback\" in data, \"Missing 'tts_feedback' in response\"\n                assert isinstance(data[\"tts_feedback\"], str) and data[\"tts_feedback\"], \"'tts_feedback' should be a non-empty string\"\n\n            except requests.exceptions.RequestException as e:\n                assert False, f\"RequestException at alias {alias}: {e}\"\n\n    # Simulate backend restart by calling a restart endpoint if available, else re-test after wait\n    # Assume a POST /admin/restart exists for simulation (if not, fallback to wait)\n    try:\n        restart_resp = requests.post(BASE_URL + \"/admin/restart\", headers=HEADERS, timeout=TIMEOUT)\n        assert restart_resp.status_code == 200, \"Backend restart failed\"\n        time.sleep(5)  # wait for restart\n    except requests.exceptions.RequestException:\n        time.sleep(10)  # fallback wait\n\n    # After restart, verify persistence: send detection request and expect success\n    for alias in aliases:\n        try:\n            start = time.time()\n            response = requests.post(\n                BASE_URL + alias,\n                headers=HEADERS,\n                json=detection_payload,\n                timeout=TIMEOUT\n            )\n            latency = time.time() - start\n\n            assert response.status_code == 200, f\"Post-restart failed at alias {alias} with status {response.status_code}\"\n            assert latency < 1, f\"High latency {latency:.3f}s post-restart at alias {alias}\"\n\n            data = response.json()\n            assert \"detected_objects\" in data, \"Missing 'detected_objects' post-restart\"\n            assert \"tts_feedback\" in data and data[\"tts_feedback\"], \"Missing or empty 'tts_feedback' post-restart\"\n\n        except requests.exceptions.RequestException as e:\n            assert False, f\"RequestException post-restart at alias {alias}: {e}\"\n\ntest_real_time_object_detection_feedback_in_blind_mode()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 29, in test_real_time_object_detection_feedback_in_blind_mode\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 86, in <module>\n  File \"<string>\", line 53, in test_real_time_object_detection_feedback_in_blind_mode\nAssertionError: RequestException at alias /blindmode/object-detection: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.455Z",
    "modified": "2026-02-05T15:33:06.827Z"
  },
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "cc2a360e-dc02-43ae-be83-54083b501d57",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC004-test real-time speech to text and sound event detection in deaf mode",
    "description": "Ensure the Deaf Mode API correctly transcribes speech to text and detects environmental sounds in real-time with accurate and timely responses.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nHEADERS = {\n    \"Authorization\": \"ApiKey sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_real_time_speech_to_text_and_sound_event_detection_deaf_mode():\n    realtime_endpoint_aliases = [\"/deafmode/realtime\", \"/deaf/realtime\", \"/modes/deaf/realtime\"]\n    test_audio_payload = {\n        \"audioChunk\": \"c2FtcGxlIGF1ZGlvIGRhdGE=\"  # Base64 encoded dummy audio chunk \"sample audio data\"\n    }\n    \n    # 1. Verify rate limiting: 1000 requests allowed, send 1001 requests and expect last to fail\n    success_count = 0\n    fail_count = 0\n\n    # Pick first alias for initial testing\n    endpoint = BASE_URL + realtime_endpoint_aliases[0]\n\n    for i in range(1001):\n        try:\n            resp = requests.post(endpoint, headers=HEADERS, json=test_audio_payload, timeout=TIMEOUT)\n            if i < 1000:\n                assert resp.status_code == 200, f\"Expected HTTP 200 before rate limit, got {resp.status_code} at request {i+1}\"\n                json_resp = resp.json()\n                assert \"transcription\" in json_resp and isinstance(json_resp[\"transcription\"], str), \"Missing or invalid 'transcription' field\"\n                assert \"detectedSounds\" in json_resp and isinstance(json_resp[\"detectedSounds\"], list), \"Missing or invalid 'detectedSounds' field\"\n                success_count += 1\n            else:\n                # Expect some rate limiting error (e.g. 429)\n                assert resp.status_code in (429, 403), f\"Expected rate limit status code on request {i+1}, got {resp.status_code}\"\n                fail_count += 1\n        except (requests.RequestException, AssertionError) as e:\n            if i < 1000:\n                raise AssertionError(f\"Request {i+1} failed unexpectedly: {str(e)}\") from e\n            else:\n                # Accept failure due to rate limit on last request\n                fail_count += 1\n        time.sleep(0.01)  # small delay to avoid bursting too fast\n\n    assert success_count == 1000, f\"Expected 1000 successful requests, got {success_count}\"\n    assert fail_count >= 1, \"Expected at least 1 failure due to rate limiting\"\n\n    # 2. Verify persistence across 'restarts' (simulate restart by waiting, then test requests still succeed)\n    # Since no actual restart control, simulate by short pause and re-test\n    time.sleep(1)  # Simulate downtime and restart time\n\n    for alias in realtime_endpoint_aliases:\n        endpoint = BASE_URL + alias\n        try:\n            resp = requests.post(endpoint, headers=HEADERS, json=test_audio_payload, timeout=TIMEOUT)\n            assert resp.status_code == 200, f\"Expected HTTP 200 from alias {alias}, got {resp.status_code}\"\n            json_resp = resp.json()\n            assert \"transcription\" in json_resp and isinstance(json_resp[\"transcription\"], str), f\"Missing or invalid 'transcription' from alias {alias}\"\n            assert \"detectedSounds\" in json_resp and isinstance(json_resp[\"detectedSounds\"], list), f\"Missing or invalid 'detectedSounds' from alias {alias}\"\n        except (requests.RequestException, AssertionError) as e:\n            raise AssertionError(f\"Failed on alias {alias}: {str(e)}\") from e\n\n    # 3. Connectivity sanity check with retries\n    max_retries = 3\n    connected = False\n    for _ in range(max_retries):\n        try:\n            resp = requests.options(BASE_URL, headers=HEADERS, timeout=TIMEOUT)\n            if resp.status_code in (200, 204):\n                connected = True\n                break\n        except requests.RequestException:\n            time.sleep(1)\n    assert connected, f\"Connectivity issue: Unable to reach base URL {BASE_URL} after {max_retries} attempts\"\n\ntest_real_time_speech_to_text_and_sound_event_detection_deaf_mode()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 26, in test_real_time_speech_to_text_and_sound_event_detection_deaf_mode\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 76, in <module>\n  File \"<string>\", line 39, in test_real_time_speech_to_text_and_sound_event_detection_deaf_mode\nAssertionError: Request 1 failed unexpectedly: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.470Z",
    "modified": "2026-02-05T15:32:36.781Z"
  },
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "3568a1a4-9e7d-46de-89d5-2a484db4e105",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC005-test sign language gesture recognition api",
    "description": "Verify the Flask API for advanced gesture processing accurately recognizes sign language gestures and returns correct translations to the frontend.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nAPI_KEY_NAME = \"Antigravity\"\nAPI_KEY_VALUE = \"sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\"\nHEADERS = {API_KEY_NAME: API_KEY_VALUE}\nTIMEOUT = 30\n\ndef test_sign_language_gesture_recognition_api():\n    # Endpoint aliases to check\n    endpoints = [\n        \"/gesture/recognize\",\n        \"/v1/gesture/recognize\",\n        \"/signlanguage/gesture/recognize\"\n    ]\n\n    # Sample valid gesture payload for ASL recognition (mock example)\n    payload = {\n        \"gesture_data\": {\n            \"landmarks\": [\n                {\"x\":0.1,\"y\":0.2,\"z\":0.0},\n                {\"x\":0.15,\"y\":0.25,\"z\":0.05},\n                {\"x\":0.2,\"y\":0.3,\"z\":0.1}\n            ],\n            \"hand\": \"right\"\n        }\n    }\n\n    # Function to do a single recognition request and validate response\n    def do_request(url):\n        resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Unexpected status code {resp.status_code}\"\n        data = resp.json()\n        assert \"translation\" in data, \"Response missing 'translation'\"\n        assert isinstance(data[\"translation\"], str), \"'translation' is not string\"\n        assert len(data[\"translation\"]) > 0, \"Translation is empty\"\n        return data\n\n    # Test each route alias\n    for ep in endpoints:\n        url = BASE_URL + ep\n        result = do_request(url)\n        # Basic content check for translation string\n        assert all(c.isalpha() or c.isspace() for c in result[\"translation\"]), \"Translation contains invalid characters\"\n\n    # Test rate limit by making 1000 requests and expect no 429 errors\n    for i in range(1000):\n        url = BASE_URL + endpoints[0]\n        resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Rate limit test failed at request {i+1} with status {resp.status_code}\"\n\n    # Simulate backend restart by waiting and re-testing\n    time.sleep(3)\n\n    # Post-restart check same as initial check\n    url = BASE_URL + endpoints[0]\n    post_restart_resp = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    assert post_restart_resp.status_code == 200, \"Post-restart gesture recognition failed\"\n    post_data = post_restart_resp.json()\n    assert \"translation\" in post_data and isinstance(post_data[\"translation\"], str) and len(post_data[\"translation\"]) > 0, \"Invalid post-restart translation\"\n\ntest_sign_language_gesture_recognition_api()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 63, in <module>\n  File \"<string>\", line 43, in test_sign_language_gesture_recognition_api\n  File \"<string>\", line 32, in do_request\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.476Z",
    "modified": "2026-02-05T15:33:06.826Z"
  },
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "8e443c3c-53bf-4ea5-ae32-b42e28171919",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC006-test dashboard accessibility statistics retrieval",
    "description": "Check the dashboard API endpoint for fetching accessibility statistics and compliance metrics, ensuring data accuracy and correct visualization support.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nAPI_KEY = \"sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\"\nHEADERS = {\"Authorization\": f\"ApiKey {API_KEY}\"}\nTIMEOUT = 30\n\ndef test_dashboard_accessibility_statistics_retrieval():\n    stats_endpoint = f\"{BASE_URL}/dashboard/accessibility-statistics\"\n    rate_limit_max = 1000\n\n    # Function to validate the structure and content of the response\n    def validate_stats_response(json_data):\n        assert isinstance(json_data, dict), \"Response is not a JSON object\"\n        # Expected top-level keys based on dashboard metrics and compliance\n        expected_keys = ['statistics', 'compliance', 'visualization']\n        for key in expected_keys:\n            assert key in json_data, f\"Missing key '{key}' in response\"\n\n        # Validate statistics is a dict with numeric values\n        statistics = json_data['statistics']\n        assert isinstance(statistics, dict), \"'statistics' must be an object\"\n        for metric, value in statistics.items():\n            assert isinstance(value, (int, float)), f\"Statistic '{metric}' value must be numeric\"\n\n        # Validate compliance contains percentages or boolean indicators\n        compliance = json_data['compliance']\n        assert isinstance(compliance, dict), \"'compliance' must be an object\"\n        for metric, value in compliance.items():\n            # Allow compliance values as float percentages between 0-100 or bool\n            if isinstance(value, (int, float)):\n                assert 0 <= value <= 100, f\"Compliance metric '{metric}' out of 0-100 range\"\n            else:\n                assert isinstance(value, bool), f\"Compliance metric '{metric}' must be bool or percentage\"\n\n        # Validate visualization support: expect keys for charts/trends description\n        visualization = json_data['visualization']\n        assert isinstance(visualization, dict), \"'visualization' must be an object\"\n        viz_keys = ['charts', 'trends']\n        for k in viz_keys:\n            assert k in visualization, f\"Missing visualization key '{k}'\"\n            # The values should be list or dict representing the chart data configurations\n            assert isinstance(visualization[k], (list, dict)), f\"Visualization '{k}' should be list or dict\"\n\n    # 1. Test normal retrieval and correctness of data\n    try:\n        response = requests.get(stats_endpoint, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        json_data = response.json()\n        validate_stats_response(json_data)\n    except (requests.RequestException, AssertionError, ValueError) as e:\n        raise AssertionError(f\"Dashboard statistics retrieval failed: {e}\")\n\n    # 2. Test rate limiting by sending 1000 requests sequentially and expect no 429\n    try:\n        for i in range(rate_limit_max):\n            r = requests.get(stats_endpoint, headers=HEADERS, timeout=TIMEOUT)\n            # Allow 200 or 304 (not modified) as success, no 429\n            assert r.status_code in (200, 304), f\"Unexpected status code {r.status_code} on request {i+1}\"\n        # The 1001th request should be rate limited (>= 429)\n        r = requests.get(stats_endpoint, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 429, \"Rate limiting not enforced after 1000 requests\"\n    except AssertionError as ae:\n        raise ae\n    except requests.RequestException as re:\n        raise AssertionError(f\"Error during rate limit test: {re}\")\n\n    # 3. Simulate a server 'restart' by waiting or calling a special endpoint if exists\n    # Since no restart endpoint is specified, we simulate by waiting and re-requesting:\n    time.sleep(2)  # simulate restart wait\n\n    try:\n        # Confirm persistence after 'restart' by re-requesting\n        response_after_restart = requests.get(stats_endpoint, headers=HEADERS, timeout=TIMEOUT)\n        assert response_after_restart.status_code == 200, f\"Expected 200 OK after restart, got {response_after_restart.status_code}\"\n        validate_stats_response(response_after_restart.json())\n    except (requests.RequestException, AssertionError, ValueError) as e:\n        raise AssertionError(f\"Dashboard statistics retrieval failed after simulated restart: {e}\")\n\n    # 4. Test all known route aliases for this endpoint if any\n    # No aliases explicitly given in PRD, but assume '/dashboard/stats' and '/stats' as plausible aliases\n    route_aliases = [\n        f\"{BASE_URL}/dashboard/stats\",\n        f\"{BASE_URL}/stats\"\n    ]\n    for alias in route_aliases:\n        try:\n            alias_resp = requests.get(alias, headers=HEADERS, timeout=TIMEOUT)\n            # Either alias not implemented (404) or valid, check for valid response if 200\n            if alias_resp.status_code == 200:\n                validate_stats_response(alias_resp.json())\n            else:\n                # Accept 404 as no alias implemented but no error raised\n                assert alias_resp.status_code in (404, 405), f\"Unexpected status code {alias_resp.status_code} for alias {alias}\"\n        except (requests.RequestException, AssertionError, ValueError) as e:\n            raise AssertionError(f\"Alias route test failed for {alias}: {e}\")\n\n    # 5. Final connectivity check - one GET request to confirm service availability\n    try:\n        final_check_resp = requests.get(stats_endpoint, headers=HEADERS, timeout=TIMEOUT)\n        assert final_check_resp.status_code == 200, \"Final connectivity check failed\"\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Final connectivity check failed: {e}\")\n\n\n# Run the test\ntest_dashboard_accessibility_statistics_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 49, in test_dashboard_accessibility_statistics_retrieval\nAssertionError: Expected 200 OK, got 404\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 108, in <module>\n  File \"<string>\", line 53, in test_dashboard_accessibility_statistics_retrieval\nAssertionError: Dashboard statistics retrieval failed: Expected 200 OK, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.483Z",
    "modified": "2026-02-05T15:33:06.822Z"
  },
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "a3a2c005-dc96-47b3-ac28-26e9eb3256d3",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC007-test user profile and accessibility preferences update",
    "description": "Validate the API endpoint for updating user profile information and accessibility preferences, ensuring data is saved securely and input is sanitized.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nAPI_KEY = \"sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\"\nHEADERS = {\n    \"Authorization\": f\"ApiKey {API_KEY}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_user_profile_and_accessibility_preferences_update():\n    # Step 1: Create a new user profile (simulate user creation)\n    create_payload = {\n        \"username\": \"testuser_tc007\",\n        \"email\": \"testuser_tc007@example.com\",\n        \"password\": \"SecureP@ssw0rd123!\"\n    }\n    user_id = None\n    try:\n        # Create user\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/users/register\",\n            json=create_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"User creation failed: {create_resp.text}\"\n        user_data = create_resp.json()\n        user_id = user_data.get(\"id\")\n        assert user_id is not None, \"User ID not returned on creation\"\n\n        # Authenticate user to obtain JWT for update permissions\n        login_payload = {\n            \"username\": create_payload[\"username\"],\n            \"password\": create_payload[\"password\"]\n        }\n        login_resp = requests.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json=login_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        token = login_resp.json().get(\"token\")\n        assert token, \"JWT token not provided on login\"\n\n        auth_headers = {\n            **HEADERS,\n            \"Authorization\": f\"Bearer {token}\"\n        }\n\n        # Step 2: Update user profile and accessibility preferences\n        update_payload = {\n            \"profile\": {\n                \"firstName\": \"Test\",\n                \"lastName\": \"User\",\n                \"email\": \"testuser_updated_tc007@example.com\",\n                \"phone\": \"+1234567890\",\n                \"address\": \"123 Accessibility St, AI City\"\n            },\n            \"accessibilityPreferences\": {\n                \"blindMode\": True,\n                \"deafMode\": False,\n                \"signLanguageMode\": True,\n                \"voiceNavigationSpeed\": 1.5,\n                \"screenReaderVolume\": 75,\n                \"captioningEnabled\": True,\n                \"preferredSignLanguage\": \"ASL\"\n            }\n        }\n        update_resp = requests.put(\n            f\"{BASE_URL}/api/users/{user_id}/profile\",\n            json=update_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert update_resp.status_code == 200, f\"Profile update failed: {update_resp.text}\"\n        updated_data = update_resp.json()\n\n        # Validate updated profile fields\n        profile = updated_data.get(\"profile\")\n        prefs = updated_data.get(\"accessibilityPreferences\")\n        assert profile is not None and prefs is not None, \"Updated data structure missing fields\"\n        assert profile.get(\"firstName\") == update_payload[\"profile\"][\"firstName\"]\n        assert profile.get(\"lastName\") == update_payload[\"profile\"][\"lastName\"]\n        assert profile.get(\"email\") == update_payload[\"profile\"][\"email\"]\n        assert prefs.get(\"blindMode\") == update_payload[\"accessibilityPreferences\"][\"blindMode\"]\n        assert prefs.get(\"signLanguageMode\") == update_payload[\"accessibilityPreferences\"][\"signLanguageMode\"]\n        assert prefs.get(\"voiceNavigationSpeed\") == update_payload[\"accessibilityPreferences\"][\"voiceNavigationSpeed\"]\n\n        # Step 3: Input Sanitization check - try to inject script tags and confirm they are sanitized or rejected\n        malicious_payload = {\n            \"profile\": {\n                \"firstName\": \"<script>alert(1)</script>\",\n                \"lastName\": \"User<script>\",\n                \"email\": \"testuser<script>@example.com\",\n                \"phone\": \"+1234567890\",\n                \"address\": \"<img src=x onerror=alert(1)>\"\n            },\n            \"accessibilityPreferences\": {\n                \"blindMode\": True,\n                \"deafMode\": False\n            }\n        }\n        sanitize_resp = requests.put(\n            f\"{BASE_URL}/api/users/{user_id}/profile\",\n            json=malicious_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        # Expect 400 Bad Request or 200 with sanitized content\n        assert sanitize_resp.status_code in (200,400), f\"Sanitize check returned unexpected status: {sanitize_resp.status_code}\"\n        if sanitize_resp.status_code == 200:\n            sanitized_data = sanitize_resp.json()\n            sanitized_profile = sanitized_data.get(\"profile\", {})\n            for key, val in malicious_payload[\"profile\"].items():\n                if isinstance(val, str) and (\"<script>\" in val or \"alert\" in val or \"onerror\" in val):\n                    # Check that these strings are not present verbatim in the saved data\n                    assert sanitized_profile.get(key) != val, f\"Input not sanitized for field {key}\"\n        else:\n            # 400 Bad Request indicates rejection of malicious input - acceptable\n            pass\n\n        # Step 4: Verify persistence simulation (simulate backend restart by waiting)\n        # In real tests, would restart backend service here; simulate with delay & re-fetch\n        time.sleep(2)\n        persist_resp = requests.get(\n            f\"{BASE_URL}/api/users/{user_id}/profile\",\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert persist_resp.status_code == 200, f\"Profile fetch failed after simulated restart: {persist_resp.text}\"\n        persisted_data = persist_resp.json()\n        assert persisted_data.get(\"profile\") is not None, \"Persisted profile missing\"\n        assert persisted_data.get(\"profile\").get(\"email\") == update_payload[\"profile\"][\"email\"]\n\n        # Step 5: Verify route aliases if exist (e.g. /profile update alias)\n        alias_resp = requests.put(\n            f\"{BASE_URL}/profile/update\",\n            json=update_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        if alias_resp.status_code == 404:\n            # Alias route may not exist - acceptable\n            pass\n        else:\n            assert alias_resp.status_code == 200, f\"Alias endpoint failed with status {alias_resp.status_code}\"\n\n        # Step 6: Verify rate limiting by sending 1001 quick requests expect limiting at or below 1000\n        rate_limit_exceeded = False\n        for i in range(1001):\n            rl_resp = requests.get(\n                f\"{BASE_URL}/api/users/{user_id}/profile\",\n                headers=auth_headers,\n                timeout=TIMEOUT\n            )\n            if rl_resp.status_code == 429:\n                rate_limit_exceeded = True\n                break\n            assert rl_resp.status_code == 200, f\"Unexpected status during rate limit test: {rl_resp.status_code}\"\n        assert rate_limit_exceeded, \"Rate limiting not enforced at 1000 requests\"\n\n    finally:\n        # Cleanup: delete created user if possible\n        if user_id:\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/api/users/{user_id}\",\n                    headers=auth_headers if 'auth_headers' in locals() else HEADERS,\n                    timeout=TIMEOUT\n                )\n                # Accept 200 or 204 or 404 (already deleted)\n                assert del_resp.status_code in (200, 204, 404), f\"User deletion failed: {del_resp.text}\"\n            except Exception:\n                pass\n\n\ntest_user_profile_and_accessibility_preferences_update()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 180, in <module>\n  File \"<string>\", line 22, in test_user_profile_and_accessibility_preferences_update\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.488Z",
    "modified": "2026-02-05T15:36:16.441Z"
  },
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "afa2f70a-780d-409c-953f-c7b21c67e829",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC008-test jwt token validation and session management",
    "description": "Test the backend API's JWT token validation mechanism to ensure secure session management and protection against unauthorized access.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nAPI_KEY = \"sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\"\nHEADERS = {\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_jwt_token_validation_and_session_management():\n    # 1. Register a new user to get a valid JWT token (assuming /auth/register and /auth/login)\n    register_payload = {\n        \"username\": \"testuser_tc008\",\n        \"email\": \"testuser_tc008@example.com\",\n        \"password\": \"StrongPassw0rd!\"\n    }\n    login_payload = {\n        \"username\": \"testuser_tc008\",\n        \"password\": \"StrongPassw0rd!\"\n    }\n\n    user_id = None\n    jwt_token = None\n\n    try:\n        # Register user\n        r = requests.post(f\"{BASE_URL}/auth/register\", json=register_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 201 or r.status_code == 200, f\"Registration failed: {r.status_code} {r.text}\"\n        register_resp = r.json()\n        user_id = register_resp.get(\"id\") or register_resp.get(\"user_id\")\n        assert user_id is not None, \"User ID not returned on registration\"\n\n        # Login user\n        r = requests.post(f\"{BASE_URL}/auth/login\", json=login_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Login failed: {r.status_code} {r.text}\"\n        login_resp = r.json()\n        jwt_token = login_resp.get(\"token\") or login_resp.get(\"jwt\")\n        assert jwt_token is not None, \"JWT token not returned on login\"\n\n        auth_headers = {**HEADERS, \"Authorization\": f\"Bearer {jwt_token}\"}\n\n        # 2. Verify valid token access protected endpoint (/dashboard/profile or /user/profile assumed)\n        r = requests.get(f\"{BASE_URL}/user/profile\", headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Access with valid JWT failed: {r.status_code} {r.text}\"\n\n        # 3. Verify invalid token rejected\n        invalid_headers = {**HEADERS, \"Authorization\": \"Bearer invalidtoken123\"}\n        r = requests.get(f\"{BASE_URL}/user/profile\", headers=invalid_headers, timeout=TIMEOUT)\n        assert r.status_code in (401,403), f\"Invalid JWT token accepted: {r.status_code} {r.text}\"\n\n        # 4. Verify no token rejected\n        r = requests.get(f\"{BASE_URL}/user/profile\", headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code in (401,403), f\"No JWT token accepted: {r.status_code} {r.text}\"\n\n        # 5. Verify session persistence simulation - by token reuse after simulated restart\n        # Simulate restart by waiting and doing another call with same token\n        time.sleep(2)\n        r = requests.get(f\"{BASE_URL}/user/profile\", headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Token not persistent after wait: {r.status_code} {r.text}\"\n\n        # 6. Verify route aliases for /user/profile (try /profile and /dashboard/profile if applicable)\n        for alias in [\"/profile\", \"/dashboard/profile\"]:\n            r = requests.get(f\"{BASE_URL}{alias}\", headers=auth_headers, timeout=TIMEOUT)\n            assert r.status_code == 200, f\"Route alias {alias} failed: {r.status_code} {r.text}\"\n\n        # 7. Verify rate limiting (max 1000 requests)\n        # We'll test by sending 1001 rapid requests to /user/profile and expect last to be rejected\n        success_count = 0\n        rate_limit_exceeded = False\n        for i in range(1001):\n            r = requests.get(f\"{BASE_URL}/user/profile\", headers=auth_headers, timeout=TIMEOUT)\n            if r.status_code == 200:\n                success_count += 1\n            elif r.status_code == 429:\n                rate_limit_exceeded = True\n                break\n            else:\n                # Any other error should fail test\n                assert False, f\"Unexpected status during rate limit test: {r.status_code} {r.text}\"\n        assert success_count <= 1000, \"More than 1000 requests succeeded, rate limit failed\"\n        assert rate_limit_exceeded is True, \"Rate limit not enforced (429 missing after limit)\"\n    finally:\n        # Delete user to cleanup if endpoint exists (assuming DELETE /user/{id})\n        if user_id:\n            try:\n                delete_headers = {**HEADERS}\n                if jwt_token:\n                    delete_headers[\"Authorization\"] = f\"Bearer {jwt_token}\"\n                requests.delete(f\"{BASE_URL}/user/{user_id}\", headers=delete_headers, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_jwt_token_validation_and_session_management()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 95, in <module>\n  File \"<string>\", line 29, in test_jwt_token_validation_and_session_management\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.494Z",
    "modified": "2026-02-05T15:36:17.175Z"
  },
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "8d2a5c4d-0658-4095-84a6-6ebc389b5d4a",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC009-test rate limiting and brute force protection",
    "description": "Verify that the API endpoints implement rate limiting and brute-force attack protection effectively to maintain security and service availability.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nAPI_KEY = \"sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\"\nHEADERS = {\"x-api-key\": API_KEY}\nREQUEST_TIMEOUT = 30\n\ndef test_rate_limiting_and_brute_force_protection():\n    \"\"\"\n    Verify that the API endpoints implement rate limiting and brute-force attack protection.\n    This test will:\n    - Send 1000 requests to key endpoints ensuring successful responses within limit.\n    - Send additional requests to confirm rate limiting enforcement.\n    - Simulate restart by waiting and re-sending requests to verify persistence.\n    - Verify HTTP status codes and rate limit response headers or error messages.\n    - Test multiple route aliases if available.\n    \"\"\"\n\n    # Define a list of representative API routes and HTTP methods to test aliases and coverage.\n    # For this test, we assume the critical endpoints to test for rate limiting are:\n    # - /api/auth/login (POST)\n    # - /api/dashboard/stats (GET)\n    # - /api/modes/select (PUT) -- dummy payload used\n    # Since no explicit routes aliases are given in PRD, we use these as main route examples.\n    # Adjust payload and params as per typical usage.\n\n    session = requests.Session()\n    session.headers.update(HEADERS)\n\n    test_routes = [\n        {\n            \"method\": \"POST\",\n            \"url\": f\"{BASE_URL}/api/auth/login\",\n            \"payload\": {\n                \"username\": \"testuser\",\n                \"password\": \"WrongPassword123!\"  # Intentionally invalid for brute-force test\n            }\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": f\"{BASE_URL}/api/dashboard/stats\"\n        },\n        {\n            \"method\": \"PUT\",\n            \"url\": f\"{BASE_URL}/api/modes/select\",\n            \"payload\": {\n                \"mode\": \"blind\"\n            }\n        }\n    ]\n\n    # Step 1: Send 1000 requests distributed evenly across endpoints to validate they succeed within rate limit\n    total_requests = 1000\n    per_route = total_requests // len(test_routes)\n    last_responses = []\n\n    for route in test_routes:\n        method = route[\"method\"]\n        url = route[\"url\"]\n        payload = route.get(\"payload\", None)\n\n        for i in range(per_route):\n            try:\n                if method == \"GET\":\n                    resp = session.get(url, timeout=REQUEST_TIMEOUT)\n                elif method == \"POST\":\n                    resp = session.post(url, json=payload, timeout=REQUEST_TIMEOUT)\n                elif method == \"PUT\":\n                    resp = session.put(url, json=payload, timeout=REQUEST_TIMEOUT)\n                elif method == \"DELETE\":\n                    resp = session.delete(url, timeout=REQUEST_TIMEOUT)\n                else:\n                    continue  # Unsupported method for test\n\n                last_responses.append((url, resp))\n                assert resp.status_code in (200, 201, 202, 204) or resp.status_code == 401 or resp.status_code == 403, \\\n                    f\"Unexpected status code {resp.status_code} for {method} {url}\"\n\n            except requests.RequestException as e:\n                assert False, f\"Request exception during normal rate test on {url}: {str(e)}\"\n\n    # Step 2: Send additional requests to verify rate limiting is enforced (expect 429 or equivalent)\n    rate_limit_triggered = False\n    for route in test_routes:\n        method = route[\"method\"]\n        url = route[\"url\"]\n        payload = route.get(\"payload\", None)\n\n        try:\n            # Send 5 additional requests rapidly to trigger rate limiting\n            for _ in range(5):\n                if method == \"GET\":\n                    resp = session.get(url, timeout=REQUEST_TIMEOUT)\n                elif method == \"POST\":\n                    resp = session.post(url, json=payload, timeout=REQUEST_TIMEOUT)\n                elif method == \"PUT\":\n                    resp = session.put(url, json=payload, timeout=REQUEST_TIMEOUT)\n                elif method == \"DELETE\":\n                    resp = session.delete(url, timeout=REQUEST_TIMEOUT)\n                else:\n                    continue\n\n                # Check if rate limit triggered\n                if resp.status_code == 429:\n                    rate_limit_triggered = True\n                    # Optionally check response body/message for rate limit info\n                    # No assertion failure here, we expect 429 at this stage\n                    break\n\n            if rate_limit_triggered:\n                break\n\n        except requests.RequestException as e:\n            assert False, f\"Request exception during rate limit trigger test on {url}: {str(e)}\"\n\n    assert rate_limit_triggered, \"Rate limiting was not triggered after exceeding request threshold\"\n\n    # Step 3: Simulate server restart and verify persistence of rate limiting\n    # Since we cannot restart actual server here, simulate by waiting enough time for rate limit window to reset.\n    # If rate limits should persist across restarts, a server restart simulation would be more complex.\n    # For demo, wait for 2 seconds assuming rate limit window is short or intermittent.\n\n    time.sleep(2)\n\n    # Send a request to verify rate limit reset/persistence\n    # We expect either a 429 if persistence or a 200 if reset\n\n    try:\n        response_post_restart = session.get(f\"{BASE_URL}/api/dashboard/stats\", timeout=REQUEST_TIMEOUT)\n        # Accept either 200 (reset) or 429 (persistence)\n        assert response_post_restart.status_code in (200, 429), \\\n            f\"Unexpected status code after restart simulation: {response_post_restart.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request exception after simulated restart: {str(e)}\"\n\n    # Step 4: Check presence of rate limit headers if available in responses (optional but best practice)\n    # Common headers: X-RateLimit-Limit, X-RateLimit-Remaining, Retry-After\n    for _, resp in last_responses:\n        # Headers keys are case-insensitive in requests\n        headers = resp.headers\n        has_limit = any(h in headers for h in [\"X-RateLimit-Limit\", \"x-ratelimit-limit\"])\n        has_remaining = any(h in headers for h in [\"X-RateLimit-Remaining\", \"x-ratelimit-remaining\"])\n        # If such headers exist, values should be parseable to numeric (except Retry-After)\n        if has_limit:\n            val = headers.get(\"X-RateLimit-Limit\") or headers.get(\"x-ratelimit-limit\")\n            try:\n                int(val)\n            except Exception:\n                assert False, \"X-RateLimit-Limit header value is not an integer\"\n        if has_remaining:\n            val = headers.get(\"X-RateLimit-Remaining\") or headers.get(\"x-ratelimit-remaining\")\n            try:\n                int(val)\n            except Exception:\n                assert False, \"X-RateLimit-Remaining header value is not an integer\"\n\n    # Step 5: Additional brief connectivity check to ensure no lingering connection issues\n    try:\n        resp = session.get(f\"{BASE_URL}/api/auth/login\", timeout=REQUEST_TIMEOUT)\n        assert resp.status_code in (401, 200, 403), \"Unexpected status code on connectivity check\"\n    except requests.RequestException as e:\n        assert False, f\"Connectivity issue detected: {str(e)}\"\n\ntest_rate_limiting_and_brute_force_protection()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 68, in test_rate_limiting_and_brute_force_protection\n  File \"/var/task/requests/sessions.py\", line 637, in post\n    return self.request(\"POST\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 165, in <module>\n  File \"<string>\", line 81, in test_rate_limiting_and_brute_force_protection\nAssertionError: Request exception during normal rate test on http://localhost:5000/api/auth/login: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.500Z",
    "modified": "2026-02-05T15:36:15.186Z"
  },
  {
    "projectId": "02c5167f-8b46-4c83-ae77-df2d7caa39f1",
    "testId": "3a10100b-3ec6-4dcf-9b4c-5122fd1be758",
    "userId": "e498d488-f0c1-705c-2133-a06713ad88f5",
    "title": "TC010-test input validation and sanitization for all api endpoints",
    "description": "Ensure all backend API endpoints validate and sanitize incoming requests to prevent security vulnerabilities such as injection attacks.",
    "code": "import requests\nimport random\nimport string\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nAPI_KEY = \"sbp_4ec20156f8a932a6f8d0647d2e6b0d93a4c0251f\"\nHEADERS = {\n    \"Authorization\": f\"ApiKey {API_KEY}\",\n    \"Content-Type\": \"application/json\"\n}\n\nTIMEOUT = 30\n\ndef random_string(length=10):\n    return ''.join(random.choices(string.ascii_letters + string.digits + \"<>'\\\";--(){}\", k=length))\n\ndef check_rate_limit(route, method='GET', payload=None):\n    limit = 1000\n    headers = HEADERS.copy()\n    for i in range(limit):\n        try:\n            if method == 'GET':\n                r = requests.get(route, headers=headers, timeout=TIMEOUT)\n            elif method == 'POST':\n                r = requests.post(route, headers=headers, json=payload, timeout=TIMEOUT)\n            elif method == 'PUT':\n                r = requests.put(route, headers=headers, json=payload, timeout=TIMEOUT)\n            elif method == 'DELETE':\n                r = requests.delete(route, headers=headers, timeout=TIMEOUT)\n            else:\n                return False\n            if r.status_code == 429:\n                return True\n        except requests.exceptions.RequestException:\n            return False\n    return False\n\ndef test_input_validation_and_sanitization():\n    # Collect API route info for key endpoints and their aliases (simulate from PRD knowledge)\n    # Since no explicit endpoints given, infer common REST endpoints for auth, modes, dashboard, profile, gesture\n    # We'll test injection strings on key endpoints with expected methods and payloads\n    \n    # Define endpoint info: route, method, json payload template or None for GET\n    endpoints = [\n        # Authentication endpoints\n        {'route': f\"{BASE_URL}/api/register\", 'method': 'POST', 'payload': {'username': '', 'email': '', 'password': ''}},\n        {'route': f\"{BASE_URL}/api/login\", 'method': 'POST', 'payload': {'username': '', 'password': ''}},\n        # Mode selection endpoint\n        {'route': f\"{BASE_URL}/api/modes/select\", 'method': 'POST', 'payload': {'mode': ''}},\n        {'route': f\"{BASE_URL}/api/modes\", 'method': 'GET', 'payload': None},\n        # Blind mode object detection trigger (simulate)\n        {'route': f\"{BASE_URL}/api/blindmode/detect\", 'method': 'POST', 'payload': {'image': 'base64string'}},\n        # Deaf mode speech processing\n        {'route': f\"{BASE_URL}/api/deafmode/transcribe\", 'method': 'POST', 'payload': {'audio': 'base64string'}},\n        # Sign language gesture recognition\n        {'route': f\"{BASE_URL}/api/signlanguage/recognize\", 'method': 'POST', 'payload': {'video': 'base64string'}},\n        # Dashboard stats retrieval\n        {'route': f\"{BASE_URL}/api/dashboard/stats\", 'method': 'GET', 'payload': None},\n        # Profile update\n        {'route': f\"{BASE_URL}/api/profile\", 'method': 'PUT', 'payload': {'displayName': '', 'preferences': {}}},\n    ]\n\n    # Injection payloads to test input validation and sanitization\n    injection_strings = [\n        \"<script>alert(1)</script>\",\n        \"' OR '1'='1\",\n        \"\\\" OR \\\"1\\\"=\\\"1\",\n        \"'; DROP TABLE users; --\",\n        \"${7*7}\",\n        \"<img src=x onerror=alert(1)>\",\n        \"<svg/onload=alert(1)>\",\n        \"admin'--\",\n        \"`shutdown -h now`\",\n        \"$(rm -rf /)\",\n    ]\n\n    def assert_no_server_error(response):\n        assert response.status_code < 500, f\"Server error occurred: {response.status_code}, Content: {response.text}\"\n\n    def assert_bad_request_or_success(response):\n        # The API should reject injections with 4xx or handle safely with 200/201\n        assert response.status_code in {200,201,400,401,403,422}, f\"Unexpected status code: {response.status_code}, Content: {response.text}\"\n\n    # Test route aliases and persistence simulation builtin as repeated calls below\n\n    # Rate limit check and connectivity\n    for ep in endpoints:\n        # Test rate limiting: we do a reduced check of 20 calls instead of 1000 for speed but simulate properly\n        for _ in range(20):\n            try:\n                if ep['method'] == 'GET':\n                    r = requests.get(ep['route'], headers=HEADERS, timeout=TIMEOUT)\n                elif ep['method'] == 'POST':\n                    r = requests.post(ep['route'], headers=HEADERS, json=ep['payload'] if ep['payload'] else None, timeout=TIMEOUT)\n                elif ep['method'] == 'PUT':\n                    r = requests.put(ep['route'], headers=HEADERS, json=ep['payload'] if ep['payload'] else None, timeout=TIMEOUT)\n                elif ep['method'] == 'DELETE':\n                    r = requests.delete(ep['route'], headers=HEADERS, timeout=TIMEOUT)\n                assert r.status_code != 503, f\"Service unavailable on repeated calls at {ep['route']}\"\n            except requests.exceptions.RequestException as e:\n                assert False, f\"Connectivity issue on {ep['route']}: {e}\"\n\n    # Test input validation and sanitization per endpoint\n    for ep in endpoints:\n        for inj in injection_strings:\n            payload = None\n            if ep['payload'] is not None:\n                payload = {}\n                for k, v in ep['payload'].items():\n                    # Inject injection string for string fields, keep nested dict empty or same\n                    if isinstance(v, str):\n                        payload[k] = inj\n                    elif isinstance(v, dict):\n                        # recursively fill dict with injection strings for testing\n                        payload[k] = {subk: inj for subk in v}\n                    else:\n                        payload[k] = v\n            try:\n                if ep['method'] == 'GET':\n                    r = requests.get(ep['route'], headers=HEADERS, timeout=TIMEOUT)\n                elif ep['method'] == 'POST':\n                    r = requests.post(ep['route'], headers=HEADERS, json=payload, timeout=TIMEOUT)\n                elif ep['method'] == 'PUT':\n                    r = requests.put(ep['route'], headers=HEADERS, json=payload, timeout=TIMEOUT)\n                elif ep['method'] == 'DELETE':\n                    r = requests.delete(ep['route'], headers=HEADERS, timeout=TIMEOUT)\n                else:\n                    continue\n                assert_no_server_error(r)\n                assert_bad_request_or_success(r)\n            except requests.exceptions.RequestException as e:\n                assert False, f\"Request exception on {ep['route']} with injection payload: {e}\"\n\n    # Simulate persistence check across 'restart' by calling critical endpoints twice with delay\n    critical_endpoints = [e for e in endpoints if e['method'] == 'GET' or e['method'] == 'POST']\n    for ep in critical_endpoints:\n        try:\n            if ep['method'] == 'GET':\n                r1 = requests.get(ep['route'], headers=HEADERS, timeout=TIMEOUT)\n                time.sleep(2)\n                r2 = requests.get(ep['route'], headers=HEADERS, timeout=TIMEOUT)\n            elif ep['method'] == 'POST':\n                payload = ep['payload'] or {}\n                r1 = requests.post(ep['route'], headers=HEADERS, json=payload, timeout=TIMEOUT)\n                time.sleep(2)\n                r2 = requests.post(ep['route'], headers=HEADERS, json=payload, timeout=TIMEOUT)\n            else:\n                continue\n            assert_no_server_error(r1)\n            assert_no_server_error(r2)\n            assert r1.status_code == r2.status_code, f\"Response status mismatch after restart simulation on {ep['route']}\"\n        except requests.exceptions.RequestException as e:\n            assert False, f\"Persistence check request failed on {ep['route']}: {e}\"\n\ntest_input_validation_and_sanitization()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 95, in test_input_validation_and_sanitization\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 156, in <module>\n  File \"<string>\", line 102, in test_input_validation_and_sanitization\nAssertionError: Connectivity issue on http://localhost:5000/api/register: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T15:18:44.506Z",
    "modified": "2026-02-05T15:36:18.106Z"
  }
]
